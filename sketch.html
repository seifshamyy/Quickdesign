<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Kitchen Sketch — Free Draw + Drag Select</title>
  <style>
    :root {
      /* Dark + Red accents */
      --bg0: #05060a;
      --bg1: #090b12;
      --panel: rgba(255, 255, 255, .06);
      --panel2: rgba(255, 255, 255, .045);
      --stroke: rgba(255, 255, 255, .93);
      --muted: rgba(255, 255, 255, .62);
      --muted2: rgba(255, 255, 255, .36);

      --accent: #e53935;
      /* red */
      --accent2: #ff5a5f;
      /* lighter red */
      --danger: #ff3b30;
      --warn: #ffd166;

      --shadow: 0 18px 60px rgba(0, 0, 0, .55);
      --ring: 0 0 0 3px rgba(229, 57, 53, .28);
      --radius: 16px;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(229, 57, 53, .14) 0%, transparent 58%),
        radial-gradient(900px 700px at 90% 20%, rgba(255, 90, 95, .10) 0%, transparent 58%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow: hidden;
      font-family: var(--sans);
      color: var(--stroke);
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* Top app bar */
    .topbar {
      position: fixed;
      left: 14px;
      right: 14px;
      top: 14px;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }

    .cluster {
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: auto;
    }

    .pill {
      background: linear-gradient(180deg, rgba(255, 255, 255, .07), rgba(255, 255, 255, .045));
      border: 1px solid rgba(255, 255, 255, .12);
      border-radius: 999px;
      padding: 10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .07), rgba(255, 255, 255, .045));
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 99px;
      background:
        radial-gradient(circle at 30% 30%, #fff 0%, rgba(255, 255, 255, .22) 35%, rgba(255, 255, 255, 0) 60%),
        linear-gradient(180deg, var(--accent2), var(--accent));
      box-shadow: 0 0 0 4px rgba(229, 57, 53, .16), 0 0 22px rgba(229, 57, 53, .35);
    }

    .title {
      font-weight: 800;
      letter-spacing: .2px;
    }

    /* Buttons */
    .btn {
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .05);
      color: var(--stroke);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      user-select: none;
    }

    .btn:hover {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, .07);
      border-color: rgba(255, 255, 255, .18);
    }

    .btn:active {
      transform: translateY(0px) scale(.99);
    }

    .btn[aria-pressed="true"] {
      outline: none;
      box-shadow: var(--ring);
      border-color: rgba(229, 57, 53, .55);
      background: rgba(229, 57, 53, .14);
    }

    .btn .k {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(0, 0, 0, .22);
    }

    .btn-danger {
      border-color: rgba(255, 59, 48, .45);
      background: rgba(255, 59, 48, .14);
      box-shadow: 0 0 0 1px rgba(255, 59, 48, .08) inset;
    }

    .btn-danger:hover {
      border-color: rgba(255, 59, 48, .62);
      background: rgba(255, 59, 48, .18);
    }

    .sep {
      width: 1px;
      height: 34px;
      background: rgba(255, 255, 255, .10);
      margin: 0 2px;
    }

    /* Hamburger menu */
    .menuWrap {
      position: relative;
    }

    .menuBtn {
      width: 44px;
      justify-content: center;
      padding: 10px 0;
    }

    .menu {
      position: absolute;
      right: 0;
      top: calc(100% + 10px);
      width: 240px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(18, 18, 24, .88), rgba(10, 10, 14, .78));
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      overflow: hidden;
      transform-origin: top right;
      transform: scale(.98);
      opacity: 0;
      pointer-events: none;
      transition: transform .12s ease, opacity .12s ease;
    }

    .menu.open {
      transform: scale(1);
      opacity: 1;
      pointer-events: auto;
    }

    .menuItem {
      width: 100%;
      padding: 12px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border: 0;
      background: transparent;
      color: var(--stroke);
      cursor: pointer;
      font-size: 13px;
    }

    .menuItem:hover {
      background: rgba(255, 255, 255, .06);
    }

    .menuItem .meta {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted2);
    }

    .menuHr {
      height: 1px;
      background: rgba(255, 255, 255, .10);
      margin: 6px 0;
    }

    /* Right floating panel */
    .panel {
      position: fixed;
      right: 14px;
      top: 74px;
      width: 340px;
      max-height: calc(100vh - 92px);
      overflow: auto;
      padding: 12px;
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255, 255, 255, .07), rgba(255, 255, 255, .045));
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      z-index: 9;
    }

    .panel h3 {
      margin: 6px 6px 10px;
      font-size: 14px;
      letter-spacing: .2px;
    }

    .group {
      border: 1px solid rgba(255, 255, 255, .10);
      background: rgba(0, 0, 0, .18);
      border-radius: 14px;
      padding: 10px;
      margin: 10px 0;
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 8px 6px;
    }

    .row label {
      font-size: 13px;
      color: var(--muted);
    }

    .row .val {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--stroke);
      opacity: .9;
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .switch {
      width: 44px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .14);
      background: rgba(255, 255, 255, .05);
      position: relative;
      cursor: pointer;
      transition: background .15s ease, border-color .15s ease;
    }

    .switch::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .88);
      box-shadow: 0 10px 22px rgba(0, 0, 0, .35);
      transition: transform .15s ease, background .15s ease;
    }

    .switch.on {
      background: rgba(229, 57, 53, .20);
      border-color: rgba(229, 57, 53, .55);
    }

    .switch.on::after {
      transform: translateX(18px);
      background: #fff;
    }

    input[type="range"] {
      width: 160px;
    }

    input[type="number"] {
      width: 92px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(0, 0, 0, .22);
      color: var(--stroke);
      font-family: var(--mono);
      outline: none;
    }

    select {
      width: 170px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(0, 0, 0, .22);
      color: var(--stroke);
      outline: none;
    }

    .hint {
      font-size: 12px;
      color: var(--muted2);
      line-height: 1.45;
      padding: 0 6px 6px;
    }

    /* Bottom status */
    .status {
      position: fixed;
      left: 14px;
      bottom: 14px;
      padding: 10px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .07), rgba(255, 255, 255, .045));
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 10;
    }

    .status .badge {
      font-family: var(--mono);
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(0, 0, 0, .20);
      color: rgba(255, 255, 255, .72);
    }

    .status .text {
      font-size: 12px;
      color: var(--muted);
    }

    .status .strong {
      color: var(--stroke);
    }

    /* Modal */
    .modalBackdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 18px;
    }

    .modalBackdrop.open {
      display: flex;
    }

    .modal {
      width: min(720px, 100%);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(18, 18, 24, .92), rgba(10, 10, 14, .86));
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .modalHeader {
      padding: 14px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, .10);
    }

    .modalHeader .h {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 800;
      letter-spacing: .2px;
    }

    .modalHeader .chip {
      font-family: var(--mono);
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(229, 57, 53, .35);
      background: rgba(229, 57, 53, .12);
      color: rgba(255, 255, 255, .86);
    }

    .modalBody {
      padding: 14px;
      color: rgba(255, 255, 255, .86);
      line-height: 1.6;
      font-size: 13px;
    }

    .kbd {
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(0, 0, 0, .25);
      color: rgba(255, 255, 255, .88);
      display: inline-block;
      margin: 0 6px 0 0;
    }

    .li {
      padding: 10px 10px;
      border: 1px solid rgba(255, 255, 255, .10);
      background: rgba(255, 255, 255, .04);
      border-radius: 14px;
      margin: 8px 0;
    }

    /* Scrollbar subtle */
    .panel::-webkit-scrollbar {
      width: 10px;
    }

    .panel::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, .10);
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: content-box;
    }

    .panel::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, .10);
      border-radius: 999px;
    }

    @supports (padding: env(safe-area-inset-top)) {
      .topbar {
        top: calc(14px + env(safe-area-inset-top));
      }

      .panel {
        top: calc(74px + env(safe-area-inset-top));
      }

      .status {
        bottom: calc(14px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="topbar">
    <div class="cluster">
      <div class="brand">
        <div class="dot"></div>
        <div class="title">Kitchen Sketch</div>
      </div>

      <div class="pill cluster" style="gap:8px;">
        <button class="btn" id="toolSelect" aria-pressed="true" title="Select/Move (V)">
          <span>Select</span><span class="k">V</span>
        </button>
        <button class="btn" id="toolLine" aria-pressed="false" title="Draw Walls (L)">
          <span>Wall</span><span class="k">L</span>
        </button>
        <button class="btn" id="toolDoor" aria-pressed="false" title="Door Tag (D)">
          <span>Door</span><span class="k">D</span>
        </button>
        <button class="btn" id="toolWindow" aria-pressed="false" title="Window Tag (W)">
          <span>Window</span><span class="k">W</span>
        </button>
        <div class="sep"></div>
        <button class="btn" id="btnSketchDone" title="Finish and Generate"
          style="color:var(--accent); border-color:var(--accent);">
          <span>DONE / SEND</span>
          <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none">
            <polyline points="20 6 9 17 4 12"></polyline>
          </svg>
        </button>
        <div class="sep"></div>
        <button class="btn" id="btnUndo" title="Undo (Ctrl/Cmd+Z)">
          <span>Undo</span><span class="k">⌘Z</span>
        </button>
        <button class="btn" id="btnRedo" title="Redo (Ctrl/Cmd+Shift+Z)">
          <span>Redo</span><span class="k">⇧⌘Z</span>
        </button>
      </div>
    </div>

    <div class="cluster">
      <div class="pill cluster" style="gap:8px;">
        <button class="btn btn-danger" id="btnResetView" title="Reset View (0)">
          <span>Reset</span><span class="k">0</span>
        </button>
        <button class="btn" id="btnClear" title="Clear All (Shift+Del)">
          <span>Clear</span>
        </button>

        <div class="menuWrap">
          <button class="btn menuBtn" id="btnMenu" aria-expanded="false" title="Menu">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M4 7h16M4 12h16M4 17h16" stroke="rgba(255,255,255,.92)" stroke-width="2"
                stroke-linecap="round" />
            </svg>
          </button>

          <div class="menu" id="menu">
            <button class="menuItem" id="miShortcuts">
              <span>Shortcuts</span><span class="meta">?</span>
            </button>
            <div class="menuHr"></div>
            <button class="menuItem" id="miExportPNG">
              <span>Export PNG</span><span class="meta">.png</span>
            </button>
            <button class="menuItem" id="miExportJSON">
              <span>Export JSON</span><span class="meta">.json</span>
            </button>
            <button class="menuItem" id="miImportJSON">
              <span>Import</span><span class="meta">.json</span>
            </button>
            <div class="menuHr"></div>
            <button class="menuItem" id="miExportISO">
              <span>Export 3D</span><span class="meta">.jpg</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel" id="panel">
    <h3>Style + Precision</h3>

    <div class="group">
      <div class="row">
        <label>Snap Points</label>
        <div class="toggle">
          <div class="switch on" id="swSnap"></div>
          <div class="val" id="snapVal">ON</div>
        </div>
      </div>
      <div class="row">
        <label>Snap to Grid</label>
        <div class="toggle">
          <div class="switch" id="swGrid"></div>
          <div class="val" id="gridVal">OFF</div>
        </div>
      </div>
      <div class="row">
        <label>Angles</label>
        <div class="toggle">
          <div class="switch on" id="swAngles"></div>
          <div class="val" id="anglesVal">ON</div>
        </div>
      </div>
      <div class="row">
        <label>Lengths</label>
        <div class="toggle">
          <div class="switch on" id="swLengths"></div>
          <div class="val" id="lengthsVal">ON</div>
        </div>
      </div>
      <div class="row">
        <label>Outline stroke</label>
        <div class="toggle">
          <div class="switch on" id="swOutline"></div>
          <div class="val" id="outlineVal">ON</div>
        </div>
      </div>
      <div class="hint">
        Snap to Grid is OFF by default for free drawing. Drag to marquee select.
      </div>
    </div>

    <div class="group">
      <div class="row">
        <label>Wall width</label>
        <div class="toggle">
          <input id="wallWidth" type="range" min="1" max="16" step="1" value="6" />
          <div class="val" id="wallWidthVal">6</div>
        </div>
      </div>
      <div class="row">
        <label>Line style</label>
        <select id="lineStyle">
          <option value="solid" selected>Solid</option>
          <option value="dashed">Dashed</option>
          <option value="dotted">Dotted</option>
        </select>
      </div>
      <div class="row">
        <label>Snap radius (px)</label>
        <div class="toggle">
          <input id="snapRadius" type="range" min="6" max="36" step="1" value="18" />
          <div class="val" id="snapRadiusVal">18</div>
        </div>
      </div>
      <div class="row">
        <label>Grid size (px)</label>
        <div class="toggle">
          <input id="gridSize" type="range" min="5" max="80" step="1" value="32" />
          <div class="val" id="gridSizeVal">32</div>
        </div>
      </div>
      <div class="row">
        <label>Scale (px per meter)</label>
        <input id="pxPerMeter" type="number" min="20" max="2000" step="5" value="120" />
      </div>
    </div>
  </div>

  <div class="status" id="status">
    <span class="badge" id="modeBadge">MODE: SELECT</span>
    <span class="text" id="statusText"><span class="strong">Space</span> to pan • <span class="strong">L</span> to draw
      walls</span>
  </div>

  <!-- Shortcuts modal -->
  <div class="modalBackdrop" id="shortcutsModal">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Shortcuts">
      <div class="modalHeader">
        <div class="h">
          Shortcuts <span class="chip">Pro</span>
        </div>
        <button class="btn" id="btnCloseShortcuts" title="Close (Esc)">
          <span>Close</span><span class="k">Esc</span>
        </button>
      </div>
      <div class="modalBody">
        <div class="li"><span class="kbd">V</span>Select / Move (Drag background to box select)</div>
        <div class="li"><span class="kbd">L</span>Wall tool (click to place points, <span class="kbd">Enter</span>
          finish, <span class="kbd">Esc</span> cancel)</div>
        <div class="li"><span class="kbd">D</span>Door tag (click a wall). While a door is selected: <span
            class="kbd">R</span> rotate swing, <span class="kbd">F</span> flip side</div>
        <div class="li"><span class="kbd">W</span>Window tag (click a wall). While a tag is selected: <span
            class="kbd">[</span>/<span class="kbd">]</span> width</div>
        <div class="li"><span class="kbd">Space</span>Pan (drag)</div>
        <div class="li"><span class="kbd">Wheel</span>Zoom (toward cursor)</div>
        <div class="li"><span class="kbd">Alt</span>Temporarily disable snapping</div>
        <div class="li"><span class="kbd">Shift</span>Angle constrain while drawing / Add to selection</div>
        <div class="li"><span class="kbd">Delete</span>Delete selection • <span class="kbd">Shift</span>+<span
            class="kbd">Delete</span> clear all</div>
        <div class="li"><span class="kbd">Ctrl/Cmd</span>+<span class="kbd">Z</span> undo • <span
            class="kbd">Ctrl/Cmd</span>+<span class="kbd">Shift</span>+<span class="kbd">Z</span> redo</div>
        <div class="li"><span class="kbd">0</span>Reset view</div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    (() => {
      /* =========================
          Utilities
      ========================= */
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const dist2 = (ax, ay, bx, by) => (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
      const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);
      const lerp = (a, b, t) => a + (b - a) * t;
      const now = () => performance.now();
      function uid(prefix = "id") { return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16); }

      /* =========================
          Canvas + Camera
      ========================= */
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");
      let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      const camera = { x: 0, y: 0, scale: 1, minScale: 0.25, maxScale: 10.0 };

      function resize() {
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      window.addEventListener("resize", resize, { passive: true });
      resize();

      function worldToScreen(wx, wy) { return { x: (wx - camera.x) * camera.scale, y: (wy - camera.y) * camera.scale }; }
      function screenToWorld(sx, sy) { return { x: sx / camera.scale + camera.x, y: sy / camera.scale + camera.y }; }
      function screenPxToWorld(px) { return px / camera.scale; }

      /* =========================
          App State
      ========================= */
      const state = {
        points: [],          // {id,x,y}
        segments: [],        // walls: {id,a,b, style:{w, pattern}, kind:"wall"}
        tags: [],            // {id,type, segId, t, widthM, swingDeg, side}
        settings: {
          snap: true,        // Snap to geometry
          grid: false,       // Snap to grid (OFF by default for free movement)
          showAngles: true,
          showLengths: true,
          outline: true,
          wallWidth: 6,
          pattern: "solid",
          snapRadiusPx: 18,
          gridSizePx: 32,
          pxPerMeter: 120,
        }
      };

      /* =========================
          History (Undo/Redo)
      ========================= */
      const history = { stack: [], redo: [], max: 120, lastCommitAt: 0 };
      function snapshot() {
        // Use Set->Array for storage if needed, but here we store clean objects
        // selection is transient, not stored in history usually, but let's clear it on restore
        return JSON.stringify({ points: state.points, segments: state.segments, tags: state.tags, settings: state.settings });
      }
      function restore(json) {
        const o = JSON.parse(json);
        state.points = o.points || [];
        state.segments = o.segments || [];
        state.tags = o.tags || [];
        state.settings = Object.assign(state.settings, o.settings || {});
        syncUIFromState();
        clearSelection();
      }
      function commitHistory(force = false) {
        const t = now();
        if (!force && t - history.lastCommitAt < 120) return;
        history.lastCommitAt = t;
        const s = snapshot();
        if (history.stack.length && history.stack[history.stack.length - 1] === s) return;
        history.stack.push(s);
        if (history.stack.length > history.max) history.stack.shift();
        history.redo.length = 0;
      }
      function undo() {
        if (history.stack.length <= 1) return;
        const cur = history.stack.pop();
        history.redo.push(cur);
        restore(history.stack[history.stack.length - 1]);
        toast("Undo");
      }
      function redo() {
        if (!history.redo.length) return;
        const s = history.redo.pop();
        history.stack.push(s);
        restore(s);
        toast("Redo");
      }
      commitHistory(true);

      /* =========================
          Model Helpers
      ========================= */
      function getPoint(id) { return state.points.find(p => p.id === id) || null; }
      function getSeg(id) { return state.segments.find(s => s.id === id) || null; }

      function addPoint(x, y) {
        const p = { id: uid("p"), x, y };
        state.points.push(p);
        return p.id;
      }
      function addWall(aId, bId, styleOverride = null) {
        if (aId === bId) return null;
        const seg = {
          id: uid("w"),
          a: aId,
          b: bId,
          kind: "wall",
          style: styleOverride ? { ...styleOverride } : { w: state.settings.wallWidth, pattern: state.settings.pattern }
        };
        state.segments.push(seg);
        return seg.id;
      }
      function removePointIfOrphan(pointId) {
        const used = state.segments.some(s => s.a === pointId || s.b === pointId);
        if (!used) {
          const idx = state.points.findIndex(p => p.id === pointId);
          if (idx >= 0) state.points.splice(idx, 1);
        }
      }
      function deleteSegment(segId) {
        const sIdx = state.segments.findIndex(s => s.id === segId);
        if (sIdx < 0) return;
        const seg = state.segments[sIdx];

        state.tags = state.tags.filter(t => t.segId !== segId);
        state.segments.splice(sIdx, 1);

        removePointIfOrphan(seg.a);
        removePointIfOrphan(seg.b);
      }
      function deleteTag(tagId) {
        const i = state.tags.findIndex(t => t.id === tagId);
        if (i >= 0) state.tags.splice(i, 1);
      }

      function splitSegmentAt(segId, wx, wy, t) {
        const seg = getSeg(segId);
        if (!seg) return null;
        const A = getPoint(seg.a), B = getPoint(seg.b);
        if (!A || !B) return null;

        const newPid = addPoint(wx, wy);
        const oldStyle = { ...seg.style };

        const tagsOn = state.tags.filter(tt => tt.segId === segId);
        state.tags = state.tags.filter(tt => tt.segId !== segId);
        deleteSegment(segId);

        const s1Id = addWall(A.id, newPid, oldStyle);
        const s2Id = addWall(newPid, B.id, oldStyle);

        for (const tg of tagsOn) {
          if (tg.t <= t) {
            const newT = t <= 0.00001 ? 0 : tg.t / t;
            tg.segId = s1Id;
            tg.t = clamp(newT, 0, 1);
          } else {
            const denom = (1 - t);
            const newT = denom <= 0.00001 ? 1 : (tg.t - t) / denom;
            tg.segId = s2Id;
            tg.t = clamp(newT, 0, 1);
          }
          state.tags.push(tg);
        }
        return newPid;
      }

      /* =========================
          Snapping
      ========================= */
      const input = {
        pointerDown: false, pointerId: null,
        lastSx: 0, lastSy: 0,
        sx: 0, sy: 0, wx: 0, wy: 0,
        altSnapOff: false, shiftConstrain: false, spacePan: false,
      };

      function nearestPointSnap(wx, wy, radiusWorld) {
        let best = null;
        let bestD2 = radiusWorld * radiusWorld;
        for (const p of state.points) {
          const d2 = dist2(wx, wy, p.x, p.y);
          if (d2 < bestD2) {
            bestD2 = d2;
            best = { type: "point", pointId: p.id, x: p.x, y: p.y, d: Math.sqrt(d2) };
          }
        }
        return best;
      }
      function nearestEdgeSnap(wx, wy, radiusWorld) {
        let best = null;
        let bestD2 = radiusWorld * radiusWorld;

        for (const s of state.segments) {
          if (s.kind !== "wall") continue;
          const A = getPoint(s.a), B = getPoint(s.b);
          if (!A || !B) continue;

          const vx = B.x - A.x;
          const vy = B.y - A.y;
          const len2 = vx * vx + vy * vy;
          if (len2 < 1e-9) continue;

          let t = ((wx - A.x) * vx + (wy - A.y) * vy) / len2;
          t = clamp(t, 0, 1);
          const px = A.x + vx * t;
          const py = A.y + vy * t;
          const d2 = dist2(wx, wy, px, py);
          if (d2 < bestD2) {
            bestD2 = d2;
            best = { type: "edge", segId: s.id, x: px, y: py, t, d: Math.sqrt(d2) };
          }
        }
        return best;
      }
      function snap(wx, wy, allowAltDisable = true) {
        const snapOn = state.settings.snap && !(allowAltDisable && input.altSnapOff);
        if (!snapOn) return { type: "free", x: wx, y: wy };

        const rW = screenPxToWorld(state.settings.snapRadiusPx);
        const p = nearestPointSnap(wx, wy, rW);
        const e = nearestEdgeSnap(wx, wy, rW);

        if (p && e) return (p.d <= e.d) ? p : e;
        return p || e || { type: "free", x: wx, y: wy };
      }
      function gridSnap(wx, wy) {
        if (!state.settings.grid) return { x: wx, y: wy };
        // Adjust grid granularity based on zoom? 
        // The visual grid size is 'g' in world units.
        const g = screenPxToWorld(state.settings.gridSizePx);
        if (g <= 0.0000001) return { x: wx, y: wy };
        return { x: Math.round(wx / g) * g, y: Math.round(wy / g) * g };
      }
      function applyConstraints(lastPoint, wx, wy) {
        if (!input.shiftConstrain || !lastPoint) return { x: wx, y: wy };
        const dx = wx - lastPoint.x;
        const dy = wy - lastPoint.y;
        const ang = Math.atan2(dy, dx);
        const step = Math.PI / 4;
        const snappedAng = Math.round(ang / step) * step;
        const len = Math.hypot(dx, dy);
        return { x: lastPoint.x + Math.cos(snappedAng) * len, y: lastPoint.y + Math.sin(snappedAng) * len };
      }

      function nearestWallHit(wx, wy, radiusWorld) {
        const edge = nearestEdgeSnap(wx, wy, radiusWorld);
        if (!edge) return null;
        const seg = getSeg(edge.segId);
        if (!seg) return null;

        const minT = 0.06, maxT = 0.94;
        edge.t = clamp(edge.t, minT, maxT);

        const A = getPoint(seg.a), B = getPoint(seg.b);
        if (!A || !B) return null;
        edge.x = lerp(A.x, B.x, edge.t);
        edge.y = lerp(A.y, B.y, edge.t);
        return edge;
      }

      /* =========================
          Interaction + UX
      ========================= */
      const Mode = { SELECT: "select", WALL: "wall", DOOR: "door", WINDOW: "window" };
      let mode = Mode.SELECT;

      const hover = { snap: null, segId: null, pointId: null, tagId: null };
      // Revised selection to support multiple items
      const selection = { ids: new Set() };
      const drag = {
        active: false,
        kind: null, // "pan", "selection", "tag", "box"
        id: null,   // for single item drag reference if needed
        startX: 0, startY: 0, // world coords start
        currentX: 0, currentY: 0, // world coords current (for box)
        startMap: new Map() // ID -> {x,y} or other props
      };
      const draw = { active: false, lastPointId: null, preview: { x: 0, y: 0 } };

      const toastState = { text: "", until: 0 };
      function toast(msg, ms = 900) { toastState.text = msg; toastState.until = now() + ms; }

      function setMode(m) {
        mode = m;
        draw.active = false;
        draw.lastPointId = null;
        clearSelection();
        updateModeUI();
        toast(m === Mode.SELECT ? "Select / Drag Box" : m === Mode.WALL ? "Wall tool" : m === Mode.DOOR ? "Door tag" : "Window tag");
      }
      function clearSelection() { selection.ids.clear(); }

      function updateModeUI() {
        document.getElementById("toolSelect").setAttribute("aria-pressed", mode === Mode.SELECT);
        document.getElementById("toolLine").setAttribute("aria-pressed", mode === Mode.WALL);
        document.getElementById("toolDoor").setAttribute("aria-pressed", mode === Mode.DOOR);
        document.getElementById("toolWindow").setAttribute("aria-pressed", mode === Mode.WINDOW);

        const badge = document.getElementById("modeBadge");
        badge.textContent =
          mode === Mode.SELECT ? "MODE: SELECT" :
            mode === Mode.WALL ? "MODE: WALL" :
              mode === Mode.DOOR ? "MODE: DOOR" :
                "MODE: WINDOW";

        const st = document.getElementById("statusText");
        if (mode === Mode.SELECT) {
          st.innerHTML = `<span class="strong">Drag</span> background to box select • <span class="strong">Shift</span> to add`;
        } else if (mode === Mode.WALL) {
          st.innerHTML = `<span class="strong">Click</span> to place points • <span class="strong">Enter</span> finishes • <span class="strong">Esc</span> cancels`;
        } else if (mode === Mode.DOOR) {
          st.innerHTML = `<span class="strong">Click</span> a wall to place door • <span class="strong">R</span> rotates swing • <span class="strong">F</span> flips side`;
        } else {
          st.innerHTML = `<span class="strong">Click</span> a wall to place window • <span class="strong">[ / ]</span> changes width`;
        }
      }

      /* =========================
          Hit Testing
      ========================= */
      function hitPoint(wx, wy, rWorld) {
        let best = null, bestD2 = rWorld * rWorld;
        for (const p of state.points) {
          const d2 = dist2(wx, wy, p.x, p.y);
          if (d2 < bestD2) { bestD2 = d2; best = p.id; }
        }
        return best;
      }
      function pointOnSegmentDistance(wx, wy, A, B) {
        const vx = B.x - A.x, vy = B.y - A.y;
        const len2 = vx * vx + vy * vy;
        if (len2 < 1e-9) return { d: Infinity, t: 0, px: A.x, py: A.y };
        let t = ((wx - A.x) * vx + (wy - A.y) * vy) / len2;
        t = clamp(t, 0, 1);
        const px = A.x + vx * t;
        const py = A.y + vy * t;
        return { d: dist(wx, wy, px, py), t, px, py };
      }
      function hitSegment(wx, wy, rWorld) {
        let best = null, bestD = rWorld;
        for (const s of state.segments) {
          if (s.kind !== "wall") continue;
          const A = getPoint(s.a), B = getPoint(s.b);
          if (!A || !B) continue;
          const { d } = pointOnSegmentDistance(wx, wy, A, B);
          if (d < bestD) { bestD = d; best = s.id; }
        }
        return best;
      }
      function hitTag(wx, wy, rWorld) {
        let best = null, bestD = rWorld;
        for (const tg of state.tags) {
          const seg = getSeg(tg.segId);
          if (!seg) continue;
          const A = getPoint(seg.a), B = getPoint(seg.b);
          if (!A || !B) continue;
          const x = lerp(A.x, B.x, tg.t), y = lerp(A.y, B.y, tg.t);
          const d = dist(wx, wy, x, y);
          if (d < bestD) { bestD = d; best = tg.id; }
        }
        return best;
      }

      /* =========================
          Rendering
      ========================= */
      function setLinePattern(pattern, w) {
        if (pattern === "dashed") ctx.setLineDash([w * 1.6, w * 1.2]);
        else if (pattern === "dotted") ctx.setLineDash([0.1, w * 1.4]);
        else ctx.setLineDash([]);
      }

      function drawGrid() {
        const g = state.settings.gridSizePx; // Pixels on screen
        const w = canvas.width / dpr;
        const h = canvas.height / dpr;

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Draw Sub-grid for "finer" feel if zoomed in
        const worldG = screenPxToWorld(g); // World units per grid cell

        // Calculate offset
        const ox = (-camera.x * camera.scale) % g;
        const oy = (-camera.y * camera.scale) % g;

        // Main grid
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,.055)";
        ctx.beginPath();
        for (let x = ox; x < w; x += g) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
        for (let y = oy; y < h; y += g) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
        ctx.stroke();

        // Axes
        ctx.strokeStyle = "rgba(229,57,53,.13)";
        ctx.beginPath();
        const ax = (-camera.x * camera.scale);
        const ay = (-camera.y * camera.scale);
        ctx.moveTo(ax, 0); ctx.lineTo(ax, h);
        ctx.moveTo(0, ay); ctx.lineTo(w, ay);
        ctx.stroke();

        ctx.restore();
      }

      function drawWallSegment(seg, highlight = false, ghost = false) {
        const A = getPoint(seg.a), B = getPoint(seg.b);
        if (!A || !B) return;

        const aS = worldToScreen(A.x, A.y);
        const bS = worldToScreen(B.x, B.y);
        const w = seg.style?.w ?? state.settings.wallWidth;
        const pattern = seg.style?.pattern ?? state.settings.pattern;

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const lw = w * camera.scale;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        const isSelected = selection.ids.has(seg.id);
        const isHighlight = highlight || isSelected;

        if (state.settings.outline && !ghost) {
          ctx.beginPath();
          ctx.moveTo(aS.x, aS.y); ctx.lineTo(bS.x, bS.y);
          ctx.lineWidth = lw + 6;
          ctx.strokeStyle = isHighlight ? "rgba(229,57,53,.26)" : "rgba(0,0,0,.44)";
          ctx.setLineDash([]);
          ctx.stroke();
        }

        setLinePattern(pattern, lw);
        ctx.beginPath();
        ctx.moveTo(aS.x, aS.y); ctx.lineTo(bS.x, bS.y);
        ctx.lineWidth = lw;
        ctx.strokeStyle = ghost ? "rgba(255,255,255,.28)" : (isHighlight ? "rgba(229,57,53,.96)" : "rgba(255,255,255,.92)");
        ctx.stroke();

        ctx.restore();
      }

      function drawHandles() {
        const show = mode === Mode.SELECT || mode === Mode.WALL;
        if (!show) return;

        const r = 5.5;
        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        for (const p of state.points) {
          const s = worldToScreen(p.x, p.y);
          const selected = selection.ids.has(p.id);
          ctx.beginPath();
          ctx.arc(s.x, s.y, (selected ? r + 2 : r) * camera.scale, 0, Math.PI * 2);
          ctx.fillStyle = selected ? "rgba(255,90,95,.95)" : "rgba(255,255,255,.50)";
          ctx.fill();
          ctx.strokeStyle = selected ? "rgba(0,0,0,.34)" : "rgba(0,0,0,.26)";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawSnapGuide() {
        if (!hover.snap) return;
        if (!state.settings.snap || input.altSnapOff) return;
        const s = hover.snap;
        if (s.type === "free") return;

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const pS = worldToScreen(s.x, s.y);
        const pulse = 0.5 + 0.5 * Math.sin(now() / 160);
        const R = (10 + 6 * pulse);

        ctx.beginPath();
        ctx.arc(pS.x, pS.y, R, 0, Math.PI * 2);
        ctx.strokeStyle = s.type === "point" ? "rgba(255,90,95,.70)" : "rgba(255,209,102,.65)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.stroke();

        ctx.restore();
      }

      function roundRect(c, x, y, w, h, r) {
        const rr = Math.min(r, w / 2, h / 2);
        c.beginPath();
        c.moveTo(x + rr, y);
        c.arcTo(x + w, y, x + w, y + h, rr);
        c.arcTo(x + w, y + h, x, y + h, rr);
        c.arcTo(x, y + h, x, y, rr);
        c.arcTo(x, y, x + w, y, rr);
        c.closePath();
      }

      function formatMeters(m) { return (m < 10 ? m.toFixed(2) : m.toFixed(1)) + " m"; }

      function drawLengthLabel(ax, ay, bx, by, text) {
        const midx = (ax + bx) / 2, midy = (ay + by) / 2;
        const ang = Math.atan2(by - ay, bx - ax);
        const nx = Math.cos(ang + Math.PI / 2);
        const ny = Math.sin(ang + Math.PI / 2);

        const offset = 16 / camera.scale;
        const x = midx + nx * offset;
        const y = midy + ny * offset;

        const pS = worldToScreen(x, y);

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.font = `700 12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const padX = 8, h = 22;
        const w = ctx.measureText(text).width + padX * 2;

        ctx.fillStyle = "rgba(0,0,0,.42)";
        ctx.strokeStyle = "rgba(255,255,255,.10)";
        ctx.lineWidth = 1;
        roundRect(ctx, pS.x - w / 2, pS.y - h / 2, w, h, 999);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.fillText(text, pS.x, pS.y + 0.5);
        ctx.restore();
      }

      function drawLengths() {
        if (!state.settings.showLengths) return;
        const ppm = state.settings.pxPerMeter;
        if (ppm <= 0) return;

        for (const seg of state.segments) {
          if (seg.kind !== "wall") continue;
          const A = getPoint(seg.a), B = getPoint(seg.b);
          if (!A || !B) continue;
          const meters = dist(A.x, A.y, B.x, B.y) / ppm;
          drawLengthLabel(A.x, A.y, B.x, B.y, formatMeters(meters));
        }
      }

      function norm(v) {
        const l = Math.hypot(v.x, v.y);
        if (l < 1e-9) return { x: 0, y: 0 };
        return { x: v.x / l, y: v.y / l };
      }
      function angleBetween(u, v) {
        const dot = u.x * v.x + u.y * v.y;
        const lu = Math.hypot(u.x, u.y), lv = Math.hypot(v.x, v.y);
        if (lu < 1e-9 || lv < 1e-9) return null;
        const c = clamp(dot / (lu * lv), -1, 1);
        return Math.acos(c);
      }
      function drawAngleLabel(px, py, angleRad) {
        const deg = angleRad * 180 / Math.PI;
        const text = deg.toFixed(1) + "°";
        const s = worldToScreen(px, py);

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.font = `800 12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const padX = 8, h = 22;
        const w = ctx.measureText(text).width + padX * 2;

        ctx.fillStyle = "rgba(229,57,53,.16)";
        ctx.strokeStyle = "rgba(229,57,53,.44)";
        ctx.lineWidth = 1;

        roundRect(ctx, s.x - w / 2, s.y - h / 2, w, h, 999);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.fillText(text, s.x, s.y + 0.5);
        ctx.restore();
      }

      function findPrevWallFromPoint(pointId) {
        for (let i = state.segments.length - 1; i >= 0; i--) {
          const s = state.segments[i];
          if (s.kind !== "wall") continue;
          if (s.a === pointId) return { segId: s.id, other: s.b };
          if (s.b === pointId) return { segId: s.id, other: s.a };
        }
        return null;
      }

      function drawAngles() {
        if (!state.settings.showAngles) return;

        const adj = new Map();
        for (const seg of state.segments) {
          if (seg.kind !== "wall") continue;
          if (!adj.has(seg.a)) adj.set(seg.a, []);
          if (!adj.has(seg.b)) adj.set(seg.b, []);
          adj.get(seg.a).push({ segId: seg.id, other: seg.b });
          adj.get(seg.b).push({ segId: seg.id, other: seg.a });
        }

        for (const [pid, links] of adj.entries()) {
          if (links.length !== 2) continue;
          const P = getPoint(pid);
          const A = getPoint(links[0].other);
          const B = getPoint(links[1].other);
          if (!P || !A || !B) continue;

          const v1 = { x: A.x - P.x, y: A.y - P.y };
          const v2 = { x: B.x - P.x, y: B.y - P.y };
          const ang = angleBetween(v1, v2);
          if (ang == null) continue;

          const u1 = norm(v1), u2 = norm(v2);
          const bis = norm({ x: u1.x + u2.x, y: u1.y + u2.y });
          const off = 34 / camera.scale;
          drawAngleLabel(P.x + bis.x * off, P.y + bis.y * off, ang);
        }

        if (mode === Mode.WALL && draw.active && draw.lastPointId) {
          const last = getPoint(draw.lastPointId);
          if (last) {
            const prevSeg = findPrevWallFromPoint(draw.lastPointId);
            if (prevSeg) {
              const other = getPoint(prevSeg.other);
              if (other) {
                const v1 = { x: other.x - last.x, y: other.y - last.y };
                const v2 = { x: draw.preview.x - last.x, y: draw.preview.y - last.y };
                const ang = angleBetween(v1, v2);
                if (ang != null) {
                  const u1 = norm(v1), u2 = norm(v2);
                  const bis = norm({ x: u1.x + u2.x, y: u1.y + u2.y });
                  const off = 42 / camera.scale;
                  drawAngleLabel(last.x + bis.x * off, last.y + bis.y * off, ang);
                }
              }
            }
          }
        }
      }

      function drawDoor(tag, highlight = false) {
        const seg = getSeg(tag.segId);
        if (!seg) return;
        const A = getPoint(seg.a), B = getPoint(seg.b);
        if (!A || !B) return;

        const x = lerp(A.x, B.x, tag.t);
        const y = lerp(A.y, B.y, tag.t);

        const dir = norm({ x: B.x - A.x, y: B.y - A.y });
        const ppm = state.settings.pxPerMeter;
        const widthPx = clamp(tag.widthM * ppm, 40, 220);
        const half = widthPx / 2;

        const p1 = { x: x - dir.x * half, y: y - dir.y * half };
        const p2 = { x: x + dir.x * half, y: y + dir.y * half };

        const hinge = (tag.side >= 0) ? p1 : p2;
        const leafEnd = (tag.side >= 0) ? p2 : p1;

        const swingSign = tag.side;
        const swingAngle = (tag.swingDeg ?? 90) * Math.PI / 180;

        const leaf = { x: leafEnd.x - hinge.x, y: leafEnd.y - hinge.y };
        const leafLen = Math.hypot(leaf.x, leaf.y);
        const baseAng = Math.atan2(leaf.y, leaf.x);
        const arcAng = baseAng + swingSign * swingAngle;
        const arcEnd = { x: hinge.x + Math.cos(arcAng) * leafLen, y: hinge.y + Math.sin(arcAng) * leafLen };

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        const hs = worldToScreen(hinge.x, hinge.y);
        const ls = worldToScreen(leafEnd.x, leafEnd.y);
        const es = worldToScreen(arcEnd.x, arcEnd.y);

        ctx.lineWidth = 6 * camera.scale;
        ctx.lineCap = "round";
        ctx.strokeStyle = "rgba(229,57,53,.55)";
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(worldToScreen(p1.x, p1.y).x, worldToScreen(p1.x, p1.y).y);
        ctx.lineTo(worldToScreen(p2.x, p2.y).x, worldToScreen(p2.x, p2.y).y);
        ctx.stroke();

        ctx.lineWidth = 3 * camera.scale;
        ctx.strokeStyle = highlight ? "rgba(255,209,102,.95)" : "rgba(255,255,255,.86)";
        ctx.beginPath();
        ctx.moveTo(hs.x, hs.y);
        ctx.lineTo(ls.x, ls.y);
        ctx.stroke();

        ctx.strokeStyle = highlight ? "rgba(255,209,102,.72)" : "rgba(255,255,255,.52)";
        ctx.setLineDash([6 * camera.scale, 6 * camera.scale]);
        const r = dist(hs.x, hs.y, ls.x, ls.y);
        const a0 = Math.atan2(ls.y - hs.y, ls.x - hs.x);
        const a1 = Math.atan2(es.y - hs.y, es.x - hs.x);
        ctx.beginPath();
        ctx.arc(hs.x, hs.y, r, a0, a1, swingSign < 0);
        ctx.stroke();

        ctx.setLineDash([]);
        ctx.fillStyle = highlight ? "rgba(255,209,102,.95)" : "rgba(229,57,53,.95)";
        ctx.beginPath();
        ctx.arc(hs.x, hs.y, 4.6 * camera.scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function drawWindow(tag, highlight = false) {
        const seg = getSeg(tag.segId);
        if (!seg) return;
        const A = getPoint(seg.a), B = getPoint(seg.b);
        if (!A || !B) return;

        const x = lerp(A.x, B.x, tag.t);
        const y = lerp(A.y, B.y, tag.t);

        const dir = norm({ x: B.x - A.x, y: B.y - A.y });
        const n = { x: -dir.y, y: dir.x };

        const ppm = state.settings.pxPerMeter;
        const widthPx = clamp(tag.widthM * ppm, 40, 260);
        const half = widthPx / 2;

        const p1 = { x: x - dir.x * half, y: y - dir.y * half };
        const p2 = { x: x + dir.x * half, y: y + dir.y * half };

        const off = 10 / camera.scale;
        const q1 = { x: p1.x + n.x * off, y: p1.y + n.y * off };
        const q2 = { x: p2.x + n.x * off, y: p2.y + n.y * off };
        const r1 = { x: p1.x - n.x * off, y: p1.y - n.y * off };
        const r2 = { x: p2.x - n.x * off, y: p2.y - n.y * off };

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.lineCap = "round";
        ctx.lineWidth = 6 * camera.scale;
        ctx.strokeStyle = "rgba(255,90,95,.45)";
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(worldToScreen(p1.x, p1.y).x, worldToScreen(p1.x, p1.y).y);
        ctx.lineTo(worldToScreen(p2.x, p2.y).x, worldToScreen(p2.x, p2.y).y);
        ctx.stroke();

        ctx.lineWidth = 2.5 * camera.scale;
        ctx.strokeStyle = highlight ? "rgba(255,209,102,.95)" : "rgba(255,255,255,.86)";
        ctx.beginPath();
        ctx.moveTo(worldToScreen(q1.x, q1.y).x, worldToScreen(q1.x, q1.y).y);
        ctx.lineTo(worldToScreen(q2.x, q2.y).x, worldToScreen(q2.x, q2.y).y);
        ctx.moveTo(worldToScreen(r1.x, r1.y).x, worldToScreen(r1.x, r1.y).y);
        ctx.lineTo(worldToScreen(r2.x, r2.y).x, worldToScreen(r2.x, r2.y).y);
        ctx.stroke();

        const mid = { x, y };
        const t1 = { x: mid.x + n.x * (off * 0.8), y: mid.y + n.y * (off * 0.8) };
        const t2 = { x: mid.x - n.x * (off * 0.8), y: mid.y - n.y * (off * 0.8) };
        ctx.strokeStyle = "rgba(255,255,255,.50)";
        ctx.beginPath();
        ctx.moveTo(worldToScreen(t1.x, t1.y).x, worldToScreen(t1.x, t1.y).y);
        ctx.lineTo(worldToScreen(t2.x, t2.y).x, worldToScreen(t2.x, t2.y).y);
        ctx.stroke();

        ctx.restore();
      }

      function drawTags() {
        for (const tg of state.tags) {
          const highlight = selection.ids.has(tg.id) || (hover.tagId === tg.id);
          if (tg.type === "door") drawDoor(tg, highlight);
          else drawWindow(tg, highlight);
        }
      }

      function drawPreview() {
        if (mode !== Mode.WALL || !draw.active || !draw.lastPointId) return;
        const last = getPoint(draw.lastPointId);
        if (!last) return;

        const A = { x: last.x, y: last.y };
        const B = { x: draw.preview.x, y: draw.preview.y };

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const aS = worldToScreen(A.x, A.y);
        const bS = worldToScreen(B.x, B.y);
        const w = state.settings.wallWidth;

        if (state.settings.outline) {
          ctx.beginPath();
          ctx.moveTo(aS.x, aS.y); ctx.lineTo(bS.x, bS.y);
          ctx.lineWidth = (w * camera.scale) + 6;
          ctx.strokeStyle = "rgba(0,0,0,.35)";
          ctx.setLineDash([]);
          ctx.stroke();
        }
        setLinePattern(state.settings.pattern, w * camera.scale);
        ctx.beginPath();
        ctx.moveTo(aS.x, aS.y); ctx.lineTo(bS.x, bS.y);
        ctx.lineWidth = w * camera.scale;
        ctx.strokeStyle = "rgba(255,255,255,.28)";
        ctx.stroke();

        if (state.settings.showLengths) {
          const ppm = state.settings.pxPerMeter;
          const meters = dist(A.x, A.y, B.x, B.y) / ppm;
          drawLengthLabel(A.x, A.y, B.x, B.y, formatMeters(meters));
        }

        ctx.restore();
      }

      function drawSelectionBox() {
        if (drag.kind !== "box") return;

        // Convert box corners to screen
        const p1 = worldToScreen(drag.startX, drag.startY);
        const p2 = worldToScreen(drag.currentX, drag.currentY);
        const x = Math.min(p1.x, p2.x);
        const y = Math.min(p1.y, p2.y);
        const w = Math.abs(p2.x - p1.x);
        const h = Math.abs(p2.y - p1.y);

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = "rgba(255,90,95,0.15)";
        ctx.strokeStyle = "rgba(255,90,95,0.6)";
        ctx.lineWidth = 1;
        ctx.fillRect(x, y, w, h);
        ctx.strokeRect(x, y, w, h);
        ctx.restore();
      }

      function render() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        const w = canvas.width / dpr, h = canvas.height / dpr;
        const g = ctx.createRadialGradient(w * 0.2, h * 0.2, 0, w * 0.5, h * 0.5, Math.max(w, h));
        g.addColorStop(0, "rgba(255,255,255,.03)");
        g.addColorStop(1, "rgba(0,0,0,.55)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();

        drawGrid();

        for (const seg of state.segments) {
          const hi = selection.ids.has(seg.id) || (hover.segId === seg.id);
          drawWallSegment(seg, hi, false);
        }

        drawPreview();
        drawTags();
        drawLengths();
        drawAngles();
        drawHandles();
        drawSnapGuide();
        drawSelectionBox();

        if (now() < toastState.until) {
          ctx.save();
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.font = `800 12px ${getComputedStyle(document.body).fontFamily}`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const t = toastState.text;
          const pad = 10;
          const tw = ctx.measureText(t).width + pad * 2;
          const th = 28;
          const x = (canvas.width / dpr) / 2;
          const y = 64;

          ctx.fillStyle = "rgba(0,0,0,.50)";
          ctx.strokeStyle = "rgba(255,255,255,.12)";
          ctx.lineWidth = 1;
          roundRect(ctx, x - tw / 2, y - th / 2, tw, th, 999);
          ctx.fill(); ctx.stroke();

          ctx.fillStyle = "rgba(255,255,255,.92)";
          ctx.fillText(t, x, y + 0.5);
          ctx.restore();
        }

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);

      /* =========================
          Pointer + Keyboard
      ========================= */
      function updatePointerFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        input.sx = (e.clientX - rect.left);
        input.sy = (e.clientY - rect.top);
        const w = screenToWorld(input.sx, input.sy);
        input.wx = w.x;
        input.wy = w.y;

        let wx = input.wx, wy = input.wy;
        // Apply grid snap only if active
        const g = gridSnap(wx, wy);
        wx = g.x; wy = g.y;

        const s = snap(wx, wy, true);
        hover.snap = s.type === "free" ? { type: "free", x: wx, y: wy } : s;

        const rW = screenPxToWorld(12);
        hover.pointId = hitPoint(wx, wy, rW);
        hover.tagId = hitTag(wx, wy, rW);
        hover.segId = hitSegment(wx, wy, rW);
      }

      function beginPan() {
        drag.active = true;
        drag.kind = "pan";
        drag.startX = camera.x;
        drag.startY = camera.y;
      }

      function beginDragSelection(startWx, startWy) {
        drag.active = true;
        drag.kind = "selection";
        drag.startX = startWx;
        drag.startY = startWy;
        drag.startMap.clear();

        // Store initial positions of ALL selected points
        for (const pid of selection.ids) {
          // If it's a point
          const p = getPoint(pid);
          if (p) drag.startMap.set(pid, { x: p.x, y: p.y, type: "point" });

          // If it's a tag (less common to drag tags in groups, but possible)
          const tg = state.tags.find(t => t.id === pid);
          if (tg) drag.startMap.set(pid, { t: tg.t, type: "tag" });
        }
      }

      function endDrag() {
        if (drag.active) {
          if (drag.kind === "box") {
            // Finalize box selection logic here if needed (usually handled in pointerUp)
          }
          if (drag.kind === "selection") {
            commitHistory(true);
          }
          drag.active = false;
          drag.kind = null;
        }
      }

      function handlePointerDown(e) {
        canvas.setPointerCapture(e.pointerId);
        input.pointerDown = true;
        input.pointerId = e.pointerId;

        updatePointerFromEvent(e);

        if (input.spacePan) {
          beginPan();
          return;
        }

        let wx = input.wx, wy = input.wy;
        // Apply grid snap for tools
        const gg = gridSnap(wx, wy);
        wx = gg.x; wy = gg.y;

        const s = snap(wx, wy, true);
        if (s.type !== "free") { wx = s.x; wy = s.y; }

        if (mode === Mode.SELECT) {
          const rW = screenPxToWorld(12);

          // Check hits in priority: Tag -> Point -> Segment
          const tHit = hitTag(wx, wy, rW);
          const pHit = hitPoint(wx, wy, rW);
          const sHit = hitSegment(wx, wy, rW);

          const hitId = tHit || pHit || sHit;
          const hitType = tHit ? "tag" : (pHit ? "point" : (sHit ? "segment" : null));

          if (hitId) {
            // Selection Logic
            if (e.shiftKey) {
              // Toggle
              if (selection.ids.has(hitId)) selection.ids.delete(hitId);
              else selection.ids.add(hitId);
            } else {
              // If clicking something NOT in current selection, clear and select new
              if (!selection.ids.has(hitId)) {
                clearSelection();
                selection.ids.add(hitId);
              }
              // If clicking something ALREADY in selection, do nothing (keep group for dragging)
            }

            // Setup Drag
            // If segment selected, we don't drag segments directly usually, unless we drag their points.
            // Simplified: Only drag points or tags.
            // If a segment is in selection, find its points and add them to selection for dragging?
            // Or just drag visual box?
            // Let's rely on Point dragging for walls.

            // Special case: If we clicked a tag, we drag that tag (or group of tags).
            // If we clicked a point, we drag point group.
            // If we clicked a segment, we likely want to move the segment (both points).

            if (hitType === "segment") {
              // If dragging a segment, add its points to drag map (even if not explicitly selected?)
              // Better UX: clicking segment selects segment. Dragging segment moves its points.
              const seg = getSeg(hitId);
              if (seg) {
                if (!selection.ids.has(seg.a)) selection.ids.add(seg.a);
                if (!selection.ids.has(seg.b)) selection.ids.add(seg.b);
              }
            }

            beginDragSelection(input.wx, input.wy);
          } else {
            // Clicked on empty space -> Start Selection Box
            if (!e.shiftKey) clearSelection();
            drag.active = true;
            drag.kind = "box";
            drag.startX = input.wx; // Use raw world coords for box
            drag.startY = input.wy;
            drag.currentX = input.wx;
            drag.currentY = input.wy;
          }
          return;
        }

        if (mode === Mode.WALL) {
          if (!draw.active) {
            let pid = null;
            if (s.type === "edge") pid = splitSegmentAt(s.segId, s.x, s.y, s.t);
            else if (s.type === "point") pid = s.pointId;
            else pid = addPoint(wx, wy);

            draw.active = true;
            draw.lastPointId = pid;
            commitHistory(true);
            return;
          } else {
            const last = getPoint(draw.lastPointId);
            if (!last) return;

            let target = applyConstraints(last, wx, wy);
            wx = target.x; wy = target.y;

            const s2 = snap(wx, wy, true);
            if (s2.type !== "free") { wx = s2.x; wy = s2.y; }

            let pid = null;
            if (s2.type === "edge") pid = splitSegmentAt(s2.segId, s2.x, s2.y, s2.t);
            else if (s2.type === "point") pid = s2.pointId;
            else pid = addPoint(wx, wy);

            if (pid === draw.lastPointId) return;

            addWall(draw.lastPointId, pid, { w: state.settings.wallWidth, pattern: state.settings.pattern });
            draw.lastPointId = pid;
            commitHistory(true);
            return;
          }
        }

        if (mode === Mode.DOOR || mode === Mode.WINDOW) {
          const hit = nearestWallHit(wx, wy, screenPxToWorld(state.settings.snapRadiusPx));
          if (!hit) { toast("Click a wall"); return; }

          const tag = {
            id: uid("t"),
            type: (mode === Mode.DOOR ? "door" : "window"),
            segId: hit.segId,
            t: hit.t,
            widthM: (mode === Mode.DOOR ? 0.9 : 1.2),
            swingDeg: 90,
            side: 1
          };
          state.tags.push(tag);
          clearSelection();
          selection.ids.add(tag.id);
          commitHistory(true);
          toast(mode === Mode.DOOR ? "Door placed" : "Window placed");
          return;
        }
      }

      function handlePointerMove(e) {
        if (!input.pointerDown) {
          updatePointerFromEvent(e);

          if (mode === Mode.WALL && draw.active && draw.lastPointId) {
            const last = getPoint(draw.lastPointId);
            let wx = input.wx, wy = input.wy;

            const gg = gridSnap(wx, wy);
            wx = gg.x; wy = gg.y;

            let s = snap(wx, wy, true);
            if (s.type !== "free") { wx = s.x; wy = s.y; }
            const constrained = applyConstraints(last, wx, wy);
            wx = constrained.x; wy = constrained.y;

            s = snap(wx, wy, true);
            if (s.type !== "free") { wx = s.x; wy = s.y; }

            draw.preview.x = wx;
            draw.preview.y = wy;
          }
          return;
        }

        updatePointerFromEvent(e);

        if (drag.active) {
          if (drag.kind === "pan") {
            const dxS = input.sx - input.lastSx;
            const dyS = input.sy - input.lastSy;
            camera.x -= dxS / camera.scale;
            camera.y -= dyS / camera.scale;
          }
          else if (drag.kind === "box") {
            drag.currentX = input.wx; // Raw coords
            drag.currentY = input.wy;
          }
          else if (drag.kind === "selection") {
            // Delta in world
            const dx = input.wx - drag.startX;
            const dy = input.wy - drag.startY;

            // Apply to all selected items
            for (const [id, initial] of drag.startMap.entries()) {
              if (initial.type === "point") {
                const p = getPoint(id);
                if (p) {
                  // If moving points, respect snap?
                  // Complex to snap group. Simply move by delta.
                  // If we want to snap the *primary* dragged item, we need to know which one caused the drag.
                  // For now, free move.
                  p.x = initial.x + dx;
                  p.y = initial.y + dy;

                  // Optional: Snap single point if only 1 is selected?
                  if (drag.startMap.size === 1) {
                    const gg = gridSnap(p.x, p.y);
                    p.x = gg.x; p.y = gg.y;
                    const s = snap(p.x, p.y, true);
                    if (s.type !== "free" && (s.type !== "point" || s.pointId !== id)) {
                      p.x = s.x; p.y = s.y;
                    }
                  }
                }
              } else if (initial.type === "tag") {
                const tg = state.tags.find(t => t.id === id);
                if (tg) {
                  // Slide along wall logic
                  // If dragging a tag, we need to re-project onto the wall line
                  const seg = getSeg(tg.segId);
                  if (seg) {
                    const A = getPoint(seg.a), B = getPoint(seg.b);
                    const { t } = pointOnSegmentDistance(input.wx, input.wy, A, B);
                    tg.t = t;
                  }
                }
              }
            }
          }
        }

        input.lastSx = input.sx;
        input.lastSy = input.sy;
      }

      function handlePointerUp(e) {
        if (drag.active && drag.kind === "box") {
          // Finalize Box Selection
          const x1 = Math.min(drag.startX, drag.currentX);
          const x2 = Math.max(drag.startX, drag.currentX);
          const y1 = Math.min(drag.startY, drag.currentY);
          const y2 = Math.max(drag.startY, drag.currentY);

          // Select Points inside
          state.points.forEach(p => {
            if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
              selection.ids.add(p.id);
            }
          });

          // Select Tags inside
          state.tags.forEach(tg => {
            const seg = getSeg(tg.segId);
            if (seg) {
              const A = getPoint(seg.a), B = getPoint(seg.b);
              const tx = lerp(A.x, B.x, tg.t);
              const ty = lerp(A.y, B.y, tg.t);
              if (tx >= x1 && tx <= x2 && ty >= y1 && ty <= y2) {
                selection.ids.add(tg.id);
              }
            }
          });

          // Select Walls if both points are selected OR if endpoints inside
          state.segments.forEach(seg => {
            const A = getPoint(seg.a);
            const B = getPoint(seg.b);
            const aIn = A && A.x >= x1 && A.x <= x2 && A.y >= y1 && A.y <= y2;
            const bIn = B && B.x >= x1 && B.x <= x2 && B.y >= y1 && B.y <= y2;
            if (aIn && bIn) {
              selection.ids.add(seg.id);
            }
          });
        }

        input.pointerDown = false;
        input.pointerId = null;
        endDrag();
      }

      canvas.addEventListener("pointerdown", (e) => {
        input.lastSx = input.sx; input.lastSy = input.sy;
        handlePointerDown(e);
      });
      canvas.addEventListener("pointermove", handlePointerMove);
      canvas.addEventListener("pointerup", handlePointerUp);
      canvas.addEventListener("pointercancel", handlePointerUp);

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const sx = (e.clientX - rect.left);
        const sy = (e.clientY - rect.top);
        const before = screenToWorld(sx, sy);

        const delta = -e.deltaY;
        const zoom = Math.exp(delta * 0.0012);
        const next = clamp(camera.scale * zoom, camera.minScale, camera.maxScale);

        camera.scale = next;
        const after = screenToWorld(sx, sy);
        camera.x += (before.x - after.x);
        camera.y += (before.y - after.y);
      }, { passive: false });

      function finishPolyline() {
        if (mode !== Mode.WALL || !draw.active) return;
        draw.active = false;
        draw.lastPointId = null;
        toast("Polyline finished");
        commitHistory(true);
      }
      function cancelPolyline() {
        if (mode !== Mode.WALL || !draw.active) return;
        draw.active = false;
        draw.lastPointId = null;
        toast("Cancelled");
      }

      /* =========================
          Keyboard shortcuts
      ========================= */
      window.addEventListener("keydown", (e) => {
        if (e.key === "Shift") input.shiftConstrain = true;
        if (e.key === "Alt") input.altSnapOff = true;
        if (e.code === "Space") input.spacePan = true;

        const isMac = navigator.platform.toUpperCase().includes("MAC");
        const ctrlOrCmd = isMac ? e.metaKey : e.ctrlKey;

        if (ctrlOrCmd && (e.key === "z" || e.key === "Z")) {
          e.preventDefault();
          if (e.shiftKey) redo(); else undo();
          return;
        }

        if (!ctrlOrCmd) {
          if (e.key === "v" || e.key === "V") setMode(Mode.SELECT);
          if (e.key === "l" || e.key === "L") setMode(Mode.WALL);
          if (e.key === "d" || e.key === "D") setMode(Mode.DOOR);
          if (e.key === "w" || e.key === "W") setMode(Mode.WINDOW);
          if (e.key === "0") resetView();
        }

        if (e.key === "Enter") finishPolyline();
        if (e.key === "Escape") {
          cancelPolyline();
          closeShortcuts();
          closeMenu();
          clearSelection();
        }

        if (e.key === "Delete" || e.key === "Backspace") {
          if (e.shiftKey) { clearAll(); return; }

          if (selection.ids.size === 0) return;

          // Delete loop
          let deletedCount = 0;
          // Convert to array to avoid modification issues during iteration
          const toDelete = Array.from(selection.ids);

          toDelete.forEach(id => {
            // Check type
            const isSeg = state.segments.find(s => s.id === id);
            const isPt = state.points.find(p => p.id === id);
            const isTag = state.tags.find(t => t.id === id);

            if (isSeg) deleteSegment(id);
            else if (isPt) {
              // Deleting a point deletes connected segments
              const connected = state.segments.filter(s => s.a === id || s.b === id).map(s => s.id);
              connected.forEach(sid => deleteSegment(sid));
              const idx = state.points.findIndex(p => p.id === id);
              if (idx >= 0) state.points.splice(idx, 1);
            }
            else if (isTag) deleteTag(id);

            deletedCount++;
          });

          clearSelection();
          commitHistory(true);
          toast(`Deleted ${deletedCount} items`);
        }

        // Handle shortcuts for SINGLE selected tags
        if (selection.ids.size === 1) {
          const id = selection.ids.values().next().value;
          const tg = state.tags.find(t => t.id === id);
          if (tg) {
            if (e.key === "r" || e.key === "R") {
              tg.swingDeg = (tg.swingDeg === 90 ? 120 : tg.swingDeg === 120 ? 60 : 90);
              commitHistory(true);
              toast("Door swing: " + tg.swingDeg + "°");
            }
            if (e.key === "f" || e.key === "F") {
              tg.side *= -1;
              commitHistory(true);
              toast("Flip side");
            }
            if (e.key === "[") { tg.widthM = clamp(tg.widthM - 0.1, 0.4, 2.4); commitHistory(true); }
            if (e.key === "]") { tg.widthM = clamp(tg.widthM + 0.1, 0.4, 2.4); commitHistory(true); }
          }
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "Shift") input.shiftConstrain = false;
        if (e.key === "Alt") input.altSnapOff = false;
        if (e.code === "Space") input.spacePan = false;
      });

      /* =========================
          UI Wiring
      ========================= */
      document.getElementById("toolSelect").onclick = () => setMode(Mode.SELECT);
      document.getElementById("toolLine").onclick = () => setMode(Mode.WALL);
      document.getElementById("toolDoor").onclick = () => setMode(Mode.DOOR);
      document.getElementById("toolWindow").onclick = () => setMode(Mode.WINDOW);

      document.getElementById("btnUndo").onclick = () => undo();
      document.getElementById("btnRedo").onclick = () => redo();

      function resetView() {
        camera.x = - (window.innerWidth / 2) / camera.scale;
        camera.y = - (window.innerHeight / 2) / camera.scale;
        camera.scale = 1;
        toast("View reset");
      }
      document.getElementById("btnResetView").onclick = resetView;

      function clearAll() {
        state.points = [];
        state.segments = [];
        state.tags = [];
        clearSelection();
        draw.active = false;
        commitHistory(true);
        toast("Cleared");
      }
      document.getElementById("btnClear").onclick = clearAll;

      function exportJSON() {
        const data = snapshot();
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "kitchen-sketch.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        toast("JSON exported");
      }

      function exportPNG() {
        const link = document.createElement("a");
        link.download = "kitchen-sketch.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
        toast("PNG exported");
      }

      function importJSON() {
        const inp = document.createElement("input");
        inp.type = "file";
        inp.accept = "application/json";
        inp.onchange = () => {
          const file = inp.files && inp.files[0];
          if (!file) return;
          const r = new FileReader();
          r.onload = () => {
            try {
              restore(r.result);
              history.stack = [snapshot()];
              history.redo = [];
              toast("Imported");
            } catch (err) {
              toast("Import failed");
              console.error(err);
            }
          };
          r.readAsText(file);
        };
        inp.click();
      }

      /* Hamburger menu */
      const btnMenu = document.getElementById("btnMenu");
      const menu = document.getElementById("menu");
      function openMenu() {
        menu.classList.add("open");
        btnMenu.setAttribute("aria-expanded", "true");
      }
      function closeMenu() {
        menu.classList.remove("open");
        btnMenu.setAttribute("aria-expanded", "false");
      }
      function toggleMenu() {
        if (menu.classList.contains("open")) closeMenu();
        else openMenu();
      }
      btnMenu.onclick = (e) => { e.stopPropagation(); toggleMenu(); };
      menu.onclick = (e) => e.stopPropagation();
      window.addEventListener("pointerdown", () => closeMenu());

      document.getElementById("miExportPNG").onclick = () => { closeMenu(); exportPNG(); };
      document.getElementById("miExportJSON").onclick = () => { closeMenu(); exportJSON(); };
      document.getElementById("miImportJSON").onclick = () => { closeMenu(); importJSON(); };

      /* Shortcuts modal */
      const shortcutsModal = document.getElementById("shortcutsModal");
      function openShortcuts() { shortcutsModal.classList.add("open"); }
      function closeShortcuts() { shortcutsModal.classList.remove("open"); }
      document.getElementById("miShortcuts").onclick = () => { closeMenu(); openShortcuts(); };
      document.getElementById("btnCloseShortcuts").onclick = closeShortcuts;
      shortcutsModal.addEventListener("pointerdown", (e) => {
        if (e.target === shortcutsModal) closeShortcuts();
      });

      /* Switch helpers */
      function bindSwitch(id, getter, setter, labelId) {
        const el = document.getElementById(id);
        const lab = document.getElementById(labelId);
        el.onclick = () => {
          setter(!getter());
          el.classList.toggle("on", getter());
          lab.textContent = getter() ? "ON" : "OFF";
          commitHistory(true);
        };
      }
      bindSwitch("swSnap", () => state.settings.snap, v => state.settings.snap = v, "snapVal");
      bindSwitch("swGrid", () => state.settings.grid, v => state.settings.grid = v, "gridVal");
      bindSwitch("swAngles", () => state.settings.showAngles, v => state.settings.showAngles = v, "anglesVal");
      bindSwitch("swLengths", () => state.settings.showLengths, v => state.settings.showLengths = v, "lengthsVal");
      bindSwitch("swOutline", () => state.settings.outline, v => state.settings.outline = v, "outlineVal");

      const wallWidth = document.getElementById("wallWidth");
      const wallWidthVal = document.getElementById("wallWidthVal");
      wallWidth.oninput = () => { state.settings.wallWidth = parseInt(wallWidth.value, 10); wallWidthVal.textContent = wallWidth.value; };
      wallWidth.onchange = () => commitHistory(true);

      const lineStyle = document.getElementById("lineStyle");
      lineStyle.onchange = () => { state.settings.pattern = lineStyle.value; commitHistory(true); };

      const snapRadius = document.getElementById("snapRadius");
      const snapRadiusVal = document.getElementById("snapRadiusVal");
      snapRadius.oninput = () => { state.settings.snapRadiusPx = parseInt(snapRadius.value, 10); snapRadiusVal.textContent = snapRadius.value; };
      snapRadius.onchange = () => commitHistory(true);

      const gridSize = document.getElementById("gridSize");
      const gridSizeVal = document.getElementById("gridSizeVal");
      gridSize.oninput = () => { state.settings.gridSizePx = parseInt(gridSize.value, 10); gridSizeVal.textContent = gridSize.value; };
      gridSize.onchange = () => commitHistory(true);

      const pxPerMeter = document.getElementById("pxPerMeter");
      pxPerMeter.onchange = () => {
        const v = parseFloat(pxPerMeter.value);
        state.settings.pxPerMeter = clamp(isFinite(v) ? v : 120, 20, 2000);
        pxPerMeter.value = state.settings.pxPerMeter;
        commitHistory(true);
      };

      function syncUIFromState() {
        const setSw = (id, val, labelId) => {
          const el = document.getElementById(id);
          const lab = document.getElementById(labelId);
          el.classList.toggle("on", !!val);
          lab.textContent = val ? "ON" : "OFF";
        };
        setSw("swSnap", state.settings.snap, "snapVal");
        setSw("swGrid", state.settings.grid, "gridVal");
        setSw("swAngles", state.settings.showAngles, "anglesVal");
        setSw("swLengths", state.settings.showLengths, "lengthsVal");
        setSw("swOutline", state.settings.outline, "outlineVal");

        wallWidth.value = state.settings.wallWidth;
        wallWidthVal.textContent = String(state.settings.wallWidth);

        lineStyle.value = state.settings.pattern;

        snapRadius.value = state.settings.snapRadiusPx;
        snapRadiusVal.textContent = String(state.settings.snapRadiusPx);

        gridSize.value = state.settings.gridSizePx;
        gridSizeVal.textContent = String(state.settings.gridSizePx);

        pxPerMeter.value = state.settings.pxPerMeter;
      }
      syncUIFromState();

      resetView();
      updateModeUI();

      /* =========================
          Supabase Integration
      ========================= */
      const CONFIG = {
        SUPABASE_URL: 'https://whmbrguzumyatnslzfsq.supabase.co',
        SUPABASE_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndobWJyZ3V6dW15YXRuc2x6ZnNxIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0OTM1MTY4OSwiZXhwIjoyMDY0OTI3Njg5fQ.h-YbToBRx8WTW5KCk2IAYnmuhob3oiARGsnn61HwYQc',
        BUCKET: 'TREE'
      };

      // Init Supabase
      let sb;
      if (window.supabase) sb = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_KEY);

      async function exportToSupabase() {
        console.log("Starting exportToSupabase...");
        if (!sb) { console.error("Supabase not loaded"); toast("Supabase not loaded"); return; }
        if (state.points.length === 0 && state.segments.length === 0) { toast("Canvas empty"); return; }

        const btn = document.getElementById('btnSketchDone');
        const originalContent = btn.innerHTML;
        btn.innerHTML = '<span>Processing...</span>';
        btn.style.opacity = '0.7';
        btn.style.pointerEvents = 'none';

        // 1. Calculate BBox
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

        // Include points
        state.points.forEach(p => {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        });

        // Fallback if empty (shouldn't happen due to check above)
        if (minX === Infinity) { minX = 0; maxX = 1000; minY = 0; maxY = 1000; }

        // Add padding (e.g. 60 units ~ 0.5m)
        const pad = 60;
        minX -= pad; maxX += pad; minY -= pad; maxY += pad;

        const contentW = maxX - minX;
        const contentH = maxY - minY;

        // 2. Save Current State
        const saveCam = { ...camera };
        const saveW = canvas.width;
        const saveH = canvas.height;
        const saveDpr = dpr;

        try {
          // 3. Setup Export View
          const exportScale = 2.0;

          dpr = 1; // Logical pixels = physical for export simplicity
          const targetW = Math.ceil(contentW * exportScale);
          const targetH = Math.ceil(contentH * exportScale);

          // Resize canvas buffer
          canvas.width = targetW;
          canvas.height = targetH;

          // Center camera on BBox top-left
          camera.scale = exportScale;
          camera.x = minX;
          camera.y = minY;

          // Render one frame synchronously
          render();

          // 4. Capture Blob
          canvas.toBlob(async (blob) => {
            console.log("Blob captured:", blob);
            // 5. Restore View Immediately (inside callback to ensure blob is captured)
            dpr = saveDpr;
            canvas.width = saveW;
            canvas.height = saveH;
            Object.assign(camera, saveCam);
            render(); // Re-render user view

            if (!blob) throw new Error('Canvas empty during export');

            // 6. Upload
            btn.innerHTML = '<span>Uploading...</span>';

            const fileExt = 'png';
            const fileName = `sketch_${Date.now()}.${fileExt}`;
            const filePath = `${fileName}`;

            console.log("Uploading to Supabase path:", filePath);

            const { data, error } = await sb.storage
              .from(CONFIG.BUCKET)
              .upload(filePath, blob, {
                contentType: 'image/png',
                upsert: false
              });

            if (error) {
              console.error("Supabase upload error:", error);
              throw error;
            }

            const { data: { publicUrl } } = sb.storage
              .from(CONFIG.BUCKET)
              .getPublicUrl(filePath);

            console.log("Upload successful. Public URL:", publicUrl);
            toast("Upload successful!");

            // Save for fallback
            localStorage.setItem('nanobanana_sketch_url', publicUrl);

            // Redirect
            const redirectUrl = `index.html?sketch_url=${encodeURIComponent(publicUrl)}`;
            console.log("Redirecting to:", redirectUrl);

            setTimeout(() => {
              window.location.href = redirectUrl;
            }, 500);

          }, 'image/png');

        } catch (err) {
          // Error handling + Restore if failed before blob
          dpr = saveDpr;
          canvas.width = saveW;
          canvas.height = saveH;
          Object.assign(camera, saveCam);
          render();

          console.error('Export failed:', err);
          toast('Export failed: ' + err.message);
          btn.innerHTML = originalContent;
          btn.style.opacity = '1';
          btn.style.pointerEvents = 'auto';
        }
      }

      const btnDone = document.getElementById('btnSketchDone');
      if (btnDone) {
        console.log("btnSketchDone found, attaching click listener");
        btnDone.onclick = (e) => {
          console.log("btnSketchDone clicked!");
          // Prevent default just in case it's in a form (though it's not)
          e.preventDefault();
          exportToSupabase();
        };
      } else {
        console.error("CRITICAL: btnSketchDone NOT found in DOM!");
      }

    })();
  </script>
</body>

</html>